#!/usr/bin/env python

""" LICENSE

Copyright Command Prompt, Inc.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose, without fee, and without a written agreement
is hereby granted, provided that the above copyright notice and this
paragraph and the following two paragraphs appear in all copies.

IN NO EVENT SHALL THE COMMAND PROMPT, INC. BE LIABLE TO ANY PARTY FOR
DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
EVEN IF THE COMMAND PROMPT, INC. HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

THE COMMAND PROMPT, INC. SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN
"AS IS" BASIS, AND THE COMMAND PROMPT, INC. HAS NO OBLIGATIONS TO
PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

"""

# $Id$

import os
import sys
import re

from ConfigParser import *
from os import *
from sys import *
from optparse import OptionParser

# Initiate command line switches

usage = "usage: %prog [options] arg1 arg2"
parser = OptionParser(usage=usage)

parser.add_option("-F", "--file", dest="archivefilename", action="store", help="Archive file", metavar="FILE")
parser.add_option("-C", "--config", dest="configfilename", action="store",  help="the name of the archiver config file", metavar="FILE")
parser.add_option("-f", "--flush", dest="flush", action="store_true", help="Flush all remaining archives to slave")
parser.add_option("-I", "--init", dest="init", action="store_true", help="Initialize master environment")
parser.add_option("-P", "--push", dest="push", action="store_true", help="Push archives to remote host")

(options, args) = parser.parse_args()

archivefile = options.archivefilename
configfile = options.configfilename
flush = options.flush
init = options.init
push = options.push

# initiate config parser 
config = ConfigParser()
config.read(configfile)

# Set up our keys
state = config.defaults()['state']
rsync_bin = config.defaults()['rsync_bin']
protocol = config.defaults()['protocol']
slaves = config.defaults()['slaves']
user = config.defaults()['user']
r_archivedir = config.defaults()['r_archivedir']
l_archivedir = config.defaults()['l_archivedir']
timeout = config.defaults()['timeout']
notify_ok = config.defaults()['notify_ok']
notify_warning = config.defaults()['notify_warning']
notify_critical = config.defaults()['notify_critical']
debug = config.defaults()['debug']
pgdata = config.defaults()['pgdata']



def generate_slave_list_func():
""" 
We now support multiple slaves (see the README) in order do that properly 
we have to break up the string and turn it into a list
"""

   slaves = config.defaults()['slaves']
   s = str(slaves)
   s.replace("'","")
   slaves = s.split(",")
   if debug == 'on':
      print "Notice: " + str(slaves)
   return slaves



def init_env_func():
"""
Initialize the local queues so we can check each directory for left
over files
"""
   l_archivedir = config.defaults()['l_archivedir']
   queues = generate_slave_list_func()
   try:
      for host in queues:
         queue = l_archivedir + "/" + host
         os.makedirs("%s" % (queue))
   except OSError, e:
      print "ERROR: Can not make queue directories"
      print "EXCEPTION: %s" % (str(e))
      exit(1);

def check_config_func():  
""" 
Let's make sure that our directories and executables exist 
"""
   if protocol == 'file':
      pathvars = [l_archivedir,rsync_bin,pgdata,configfile]
   else:
      pathvars = [rsync_bin,pgdata,configfile]
   for element in pathvars:
      try:
         os.stat("%s" % (str(element)))
      except OSError, e:
         print "Config %s:  %s" % (str(element),str(e))
         exit(1)


def check_pgpid_func():

"""
Checks to see if postgresql is running
"""

   pidfile = '%s/postmaster.pid' % (str(pgdata))
   try:
      check = os.stat(pidfile)
      if check:
         file = open(pidfile,'r')
         line = int(file.readline())
      sendsignal = os.kill(line,0)
      return 0
   except:
      return 1



def get_pgcontroldata_func():

"""
get_pgcontroldata_func doesn't actually do anything yet. This is more
for archival purposes so we can remember the regex
"""

   try:
      cmd = os.popen("%s %s" % (str(pgcontroldata),str(pgdata)))
      #return cmd.readlines
      for row in cmd:
         match = re.search('^Prior checkpoint location: *.{1,}' , '%s' % (str(row)))
         if match != None:
            print match
   except OSError, e:
      print
      print "EXCEPTION: %s" % (str(e))
      exit(1)


def flush_check_func():
"""
Simple function to make sure we require input before flushing a system
"""

   print "\n\n"
   print "Warning! Flushing all logs will cause your slave to exit"
   print "Standby and start up. Please verify that this is exactly what you desire.\n\n"""

   print "I wish to force my slave into production: No/Yes\n\n"

   line = str(raw_input())
   if line == "Yes":
      print "Flushing all xlogs"
   elif line == "No":
      print "Exiting!"
      exit(0)
   else:
      print "Your options are Yes and No"
      exit(0)

def check_queue_func():
"""
Checks the local queue for files to send to slaves *before* sending current
transaction log
"""

  if state == 'online':
     if debug == 'on':
        print "QUEUE CHECK: %s " % (queue_transfer)
        retval = system("%s" % (queue_transfer))
        if retval:
           retval = system("%s %d" % (str(notify_critical), retval))
           exit(1)
   
def archive_func():
"""
The main archive function
"""
   if state == 'online':
      if protocol == 'rsync':
         if debug == 'on':
            print "RSYNC: %s " % (rsync_transfer)
         retval = system("%s" % (rsync_transfer))
         if retval:
            retval = system("%s %d" % (str(notify_critical), retval))
            print "Bailing out! Critical Error"
         else:
            retval = system("%s" % (str(notify_ok)))
      if protocol == 'file':
         if not push:
            if debug == 'on':
               print "FILE: %s" % (file_transfer)
               try:
                  system("%s" % (file_transfer))
               except OSError, e:
                  system("%s %d" % (str(notify_critical), retval))
                  print 
                  print "Unable to copy file %s to %s " % (str(archivefile), str(l_archivedir)) 
                  print "EXCEPTION: %e" % (str(e))
                  print
            else:
               retval = system("%s" % (str(notify_ok)))
   elif state == 'offline':
      print "ARCHIVER: We are offline, queuing archives"
      system("%s" % (str(notify_warning)))
      exit(1)
   else:
      print "I must either be online or offline. There is no NULL here"
      exit(1)

def push_func():
"""
If we are push archiving"
"""

   if protocol == 'file':
      if push:
         if debug == 'on':
            print "PUSH: %s " % (push_transfer)
            try:
               system("%s" % (push_transfer))
               system("%s" % (str(notify_ok)))
            except OSError, e:
               system("%s %d" % (str(notify_critical), retval))
               print "Bailing out! Critical Error"
               print
               print "EXCEPTION: %s" % (str(e))


# Before any actions, we check the config
if not init:
   check_config_func()

# Some command line checking

if flush:
   if configfile == None:
      parser.error("option -c is required")
      print "\n"   

if push:
   if protocol != 'file':
      parser.error("option -P requires a protocol of file")
      print "\n"

if debug == 'on':
   print config.defaults().keys()
   
# set up our transfer commands

if debug == 'on':
   scp_flags = "-vvv -o ConnectTimeout=%s -o StrictHostKeyChecking=no" % (str(timeout))
else:
   scp_flags = "-o ConnectTimeout=%s -o StrictHostKeyChecking=no" % (str(timeout))

# If we are initializing the environment

if init:
   print "We are initializing queues, one moment.\n"
   init_env_func()
   else:
      # If we are flushing archives
      if flush:
         rsync_transfer = """%s %s/pg_xlog/* -e "ssh %s"  %s@%s:%s""" % (str(rsync_bin), str(pgdata), str(scp_flags), str(user), str(slave), str(r_archivedir))
         file_transfer = "rsync -au %s/pg_xlog/* %s" % (str(pgdata),str(l_archivedir))
         flush_check_func()
         check = check_pgpid_func()
         if check == 0:
            print "ERROR: Can not enter flush mode if PG is already running"
            exit(1)
         archive_func()
         # If we aren't flushing we are either pushing or just plain old archiving
        else:
           push_transfer = """%s -azv --remove-source-files  -e "ssh %s" %s/* %s@%s:%s/""" % (str(rsync_bin), str(scp_flags), str(l_archivedir), str(user), str(slave), str(r_archivedir))
           rsync_transfer = """%s -e "ssh %s" %s %s@%s:%s""" % (str(rsync_bin), str(scp_flags), str(archivefile), str(user), str(slave), str(r_archivedir))
           file_transfer = "rsync %s/%s %s" % (str(pgdata),str(archivefile),str(l_archivedir))
           if push:
              push_func()
           else:
              archive_func()


