#!/usr/bin/env python

""" LICENSE

Copyright Command Prompt, Inc.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose, without fee, and without a written agreement
is hereby granted, provided that the above copyright notice and this
paragraph and the following two paragraphs appear in all copies.

IN NO EVENT SHALL THE COMMAND PROMPT, INC. BE LIABLE TO ANY PARTY FOR
DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
EVEN IF THE COMMAND PROMPT, INC. HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

THE COMMAND PROMPT, INC. SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN
"AS IS" BASIS, AND THE COMMAND PROMPT, INC. HAS NO OBLIGATIONS TO
PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

"""

# $Id$

import os
import sys
import re

from ConfigParser import *
from os import *
from sys import *
from optparse import OptionParser

# Initiate command line switches

usage = "usage: %prog [options] arg1 arg2"
parser = OptionParser(usage=usage)

parser.add_option("-F", "--file", dest="archivefilename", action="store", help="Archive file", metavar="FILE")
parser.add_option("-C", "--config", dest="configfilename", action="store",  help="the name of the archiver config file", metavar="FILE")
parser.add_option("-f", "--flush", dest="flush", action="store_true", help="Flush all remaining archives to slave")
parser.add_option("-I", "--init", dest="init", action="store_true", help="Initialize master environment")
parser.add_option("-P", "--push", dest="push", action="store_true", help="Push archives to remote host")

(options, args) = parser.parse_args()

archivefile = options.archivefilename
configfile = options.configfilename
flush = options.flush
init = options.init
push = options.push

# initiate config parser 
config = ConfigParser()
config.read(configfile)

# Set up our keys
state = config.defaults()['state']
rsync_bin = config.defaults()['rsync_bin']
protocol = config.defaults()['protocol']
slaves = config.defaults()['slaves']
user = config.defaults()['user']
r_archivedir = config.defaults()['r_archivedir']
l_archivedir = config.defaults()['l_archivedir']
timeout = config.defaults()['timeout']
notify_ok = config.defaults()['notify_ok']
notify_warning = config.defaults()['notify_warning']
notify_critical = config.defaults()['notify_critical']
debug = config.defaults()['debug']
pgdata = config.defaults()['pgdata']

"""
If we are not online, exit immediately
"""

if state != 'online':
   print "ARCHIVER: We are offline, queuing archives"
   system("%s" % (str(notify_warning)))
   exit(1)


def generate_slave_list_func():
   """ 
   We now support multiple slaves (see the README) in order do that properly 
   we have to break up the string and turn it into a list
   """

   slaves = config.defaults()['slaves']
   s = str(slaves)
   s.replace("'","")
   slaves = s.split(",")
   if debug == 'on':
      print "NOTICE: Your slaves are: "
      print "NOTICE: " + str(slaves)
   return slaves

def init_env_func():
   """
   Initialize the local queues so we can check each directory for left
   over files
   """
   l_archivedir = config.defaults()['l_archivedir']
   queues = generate_slave_list_func()
   try:
      for host in queues:
         queue = l_archivedir + "/" + host
         os.makedirs("%s" % (queue))
   except OSError, e:
      print "ERROR: Can not make queue directories"
      print "EXCEPTION: %s" % (str(e))
      exit(1);

def check_config_func():  
   """ 
   Let's make sure that our directories and executables exist 
   """
   if protocol == 'file':
      pathvars = [l_archivedir,rsync_bin,pgdata,configfile]
   else:
      pathvars = [rsync_bin,pgdata,configfile]
   for element in pathvars:
      try:
         os.stat("%s" % (str(element)))
      except OSError, e:
         print "Config %s:  %s" % (str(element),str(e))
         exit(1)

def check_pgpid_func():
   """
   Checks to see if postgresql is running
   """

   pidfile = '%s/postmaster.pid' % (str(pgdata))
   try:
      check = os.stat(pidfile)
      if check:
         file = open(pidfile,'r')
         line = int(file.readline())
      sendsignal = os.kill(line,0)
      return 0
   except:
      return 1


def get_pgcontroldata_func():
   """
   get_pgcontroldata_func doesn't actually do anything yet. This is more
   for archival purposes so we can remember the regex
   """

   try:
      cmd = os.popen("%s %s" % (str(pgcontroldata),str(pgdata)))
      #return cmd.readlines
      for row in cmd:
         match = re.search('^Prior checkpoint location: *.{1,}' , '%s' % (str(row)))
         if match != None:
            print match
   except OSError, e:
      print
      print "EXCEPTION: %s" % (str(e))
      exit(1)


def flush_check_func():
   """
   Simple function to make sure we require input before flushing a system
   """

   print "\n\n"
   print "Warning! Flushing all logs will cause your slave to exit"
   print "Standby and start up. Please verify that this is exactly what you desire.\n\n"""

   print "I wish to force my slave into production: No/Yes\n\n"

   line = str(raw_input())
   if line == "Yes":
      print "Flushing all xlogs"
   elif line == "No":
      print "Exiting!"
      exit(0)
   else:
      print "Your options are Yes and No"
      exit(0)

def list_queue_func():
   """
   We only want to process archives for queues that have files, so we check
   and only return a queue/slave that has files to be shipped.
   """
   queue = generate_slave_list_func()
   for slave in queue:
      queuedir = l_archivedir + "/" + str(slave)
      list_archives = os.listdir(queuedir)
      if list_archives:
         if debug == 'on':
            print "Slave: " + slave + " " + str(list_archives)
   return slave

def send_queue_func():
   """
   We are called before normal archive process in order to send queue files that have not been shipped yet.
   """
   slave = list_queue_func()
   if debug == 'on':
      print "NOTICE: processing " + slave
   for host in slave:
      queue_dir = l_archivedir + "/" + str(slave)
      queue_transfer =  """%s -azq --remove-source-files  -e "ssh %s" %s/ %s@%s:%s/""" % (str(rsync_bin), str(ssh_flags), str(queue_dir), str(user), str(slave), str(r_archivedir))
      retval = system(queue_transfer)
      if debug == 'on':
         print queue_transfer
      return retval

def archive_func():
   """
   The main archive function. 
   """
   if protocol == 'rsync':
      """ First we send the queue files (if any). If we can't we exit """
      retval = send_queue_func()
      if retval != 0:
         print "ERROR: Unable to send queued archived files"
         retval = system("%s %d" % (str(notify_warning), retval))
         exit(1)
      queue = generate_slave_list_func()
      for slave in queue:
         queue_dir = l_archivedir + "/" + str(slave)
         rsync_transfer = """%s -zq -e "ssh %s" %s %s@%s:%s""" % (str(rsync_bin), str(ssh_flags), str(archivefile), str(user), str(slave), str(r_archivedir))
         retval = system("%s" % (rsync_transfer))
         if retval:
            queue_transfer = """%s %s %s""" % (str(rsync_bin), str(archivefile), str(queue_dir)) 
	    retval = system(queue_transfer)
            if retval:
               system("%s %d" % (str(notify_critical), retval))
               exit(1)
            else:
               '''
               We exit(0) here becuase we have successfully archived "somewhere" but we still warn that something is going on so people can look in on things
               '''
               retval = system("%s %d" % (str(notify_warning), retval))
               exit(0)
         retval = system("%s" % (rsync_transfer))
         if retval:
            print "Bailing out! Critical Error"
         else:
            retval = system("%s" % (str(notify_ok)))
   if protocol == 'file':
      if not push:
         if debug == 'on':
            print "FILE: %s" % (file_transfer)
            try:
               system("%s" % (file_transfer))
            except OSError, e:
               system("%s %d" % (str(notify_critical), retval))
               print 
               print "Unable to copy file %s to %s " % (str(archivefile), str(l_archivedir)) 
               print "EXCEPTION: %e" % (str(e))
               print
         else:
            retval = system("%s" % (str(notify_ok)))
      else:
         print "I must either be online or offline. There is no NULL here"
         exit(1)

def push_func():
   """
   If we are push archiving"
   """

   if protocol == 'file':
      if push:
         if debug == 'on':
            print "PUSH: %s " % (push_transfer)
            try:
               system("%s" % (push_transfer))
               system("%s" % (str(notify_ok)))
            except OSError, e:
               system("%s %d" % (str(notify_critical), retval))
               print "Bailing out! Critical Error"
               print
               print "EXCEPTION: %s" % (str(e))


# Before any actions, we check the config
if not init:
   check_config_func()

# Some command line checking

if flush:
   if configfile == None:
      parser.error("option -c is required")
      print "\n"   

if push:
   if protocol != 'file':
      parser.error("option -P requires a protocol of file")
      print "\n"

if debug == 'on':
   print config.defaults().keys()
   
# set up our transfer commands

if debug == 'on':
   ssh_flags = "-vvv -o ConnectTimeout=%s -o StrictHostKeyChecking=no" % (str(timeout))
else:
   ssh_flags = "-o ConnectTimeout=%s -o StrictHostKeyChecking=no" % (str(timeout))

# If we are initializing the environment

if init:
   print "We are initializing queues, one moment.\n"
   init_env_func()
else:
   """ 
   A flush of the archives. We only do this if we are failing over
   """
   if flush:
      rsync_transfer = """%s -z %s/pg_xlog/* -e "ssh %s"  %s@%s:%s""" % (str(rsync_bin), str(pgdata), str(ssh_flags), str(user), str(slave), str(r_archivedir))
      file_transfer = "rsync -au %s/pg_xlog/* %s" % (str(pgdata),str(l_archivedir))
      flush_check_func()
      check = check_pgpid_func()
      if check == 0:
         print "ERROR: Can not enter flush mode if PG is already running"
         exit(1)
      archive_func()
      """
      If we aren't performing a flush we are just archiving
      """
   else:
      #file_transfer = "rsync %s/%s %s" % (str(pgdata),str(archivefile),str(l_archivedir))
      if push:
         push_transfer = """%s -azv --remove-source-files  -e "ssh %s" %s/* %s@%s:%s/""" % (str(rsync_bin), str(ssh_flags), str(l_archivedir), str(user), str(slave), str(r_archivedir))         
         push_func()
      else:
         archive_func()
